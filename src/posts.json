[{"id":0,"title":"渲染篇-剖切面的实现","content":"## 最终效果图：\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1686819652220-fd846fc8-27ee-4e30-b886-3f369954e937.png#averageHue=%230a0807&clientId=ua345d7d0-e847-4&from=paste&height=977&id=uf213fff3&originHeight=1465&originWidth=2560&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=536180&status=done&style=none&taskId=ude254908-d85b-40f2-9692-17370b3f7a7&title=&width=1706.6666666666667)\n## 背景说明\n业务场景中需要实现刨切面渲染效果，本文基于WebGL实现并尝试解释实现思路。\nDemo：[https://webgl-renderer.netlify.app/#/clip-plane](https://webgl-renderer.netlify.app/#/clip-plane)  \nGithub：\nWebGL：[https://github.com/Eric-Schecter/webgl-renderer](https://github.com/Eric-Schecter/webgl-renderer)  \nOpenGL：[https://github.com/Eric-Schecter/opengl-renderer](https://github.com/Eric-Schecter/opengl-renderer)  \n### 原始模型\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1686837920587-7ed099db-2eae-4de8-94b3-6a7d6c41e91c.png#averageHue=%23cdf799&clientId=ub4cb5497-3b23-4&from=paste&height=925&id=u564fe52f&originHeight=1388&originWidth=1342&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=462634&status=done&style=none&taskId=u10b116a7-c6f6-4e1b-97bd-74d066b4ce5&title=&width=894.6666666666666)\n## 原理解析\n### 基于刨切面的裁剪\n实现思路：在世界空间中构造一个虚拟平面，将模型分割成两部分。通过判断像素是否处于刨切面的一侧来选择保留或者舍弃。\n###### 平面的构造：\n已知平面的一般方程为：Ax+By+Cz+D=0\n其中vec3(A,B,C)三个系数构成的向量为该平面的法向量，D为该平面到原点的距离。\n基于以上结论，我们可以在世界空间中构造任意一个平面。\n###### 模型与刨切面的位置判断：\n我们设模型的世界位置信息为P(x0,y0,z0)，刨切面法线为N(A,B,C)。\n将位置信息P与平面法线N做点积得到Ax0+By0+Cz0，代入上述的平面一般方程得到：\nAx0+By0+Cz0+D=0，等价于N · P + D =0\n以为D代表平面到原点的距离，我们得到\n\n- 如果 N · P + D > 0，表示点与平面法线同侧。\n- 如果 N · P + D < 0，表示点与平面法线反侧。\n- 如果 N · P + D = 0，表示点在平面上。\n\n代码实现如下：\n```glsl\n#version 300 es\n\nlayout(location=0)in vec3 a_position;\n\nuniform mat4 u_projectMatrix;\nuniform mat4 u_viewMatrix;\nuniform mat4 u_modelMatrix;\n\nout vec3 v_pos;\n\nvoid main(){\n    v_pos=(u_modelMatrix*vec4(a_position,1.)).xyz; // get position in the world space\n    gl_Position=u_projectMatrix*u_viewMatrix*u_modelMatrix*vec4(a_position,1.f);\n}\n\n```\n```glsl\n#version 300 es\n\nprecision mediump float;\n\nuniform vec4 u_plane; // vec4(A,B,C,D)\nuniform int u_needrenderplane;\n\nin vec3 v_pos;\n\nout vec4 f_color;\n\nvoid main(){\n    // judge whether mesh is in the clipping side\n    if(u_needrenderplane==1&&dot(v_pos,u_plane.xyz)>u_plane.w){\n        discard;\n    }\n    vec3 color=(v_pos+vec3(1.f))/2.f;\n    f_color=vec4(color,1.);\n}\n\n```\n裁剪效果如下\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1686838021230-fb72094a-bfb2-4de5-af5d-1d1f0d3de11b.png#averageHue=%230b0806&clientId=ub4cb5497-3b23-4&from=paste&height=800&id=ube59b353&originHeight=1200&originWidth=1171&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=216086&status=done&style=none&taskId=u135bcf15-e811-4212-9020-b43df955b3a&title=&width=780.6666666666666)\n### 刨切面的绘制\n任何封闭的物体都有正反两面的像素信息，如下图所示，左立方体为正面，右立方体为背面。\n当物体被刨切时，会缺少正面的像素信息，正是我们需要着色的区域。\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1686839848903-5d168a46-fbbe-4f55-960b-116ba9377803.png#averageHue=%23838583&clientId=ub4cb5497-3b23-4&from=paste&height=267&id=A5bqw&originHeight=401&originWidth=824&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=131276&status=done&style=none&taskId=u29168d29-32bd-489c-8371-5a8541d267a&title=&width=549.3333333333334)\n基于以上结论，借助模型测试，我们做以下渲染获取刨切面作用区域：\n\n1. 渲染裁剪后模型正面，渲染物体并将模板信息加1\n2. 渲染裁剪后模型背面，渲染物体并将模板信息减1\n3. 渲染裁剪平面，仅当模板信息不为0的情况渲染。\n\n代码如下，仅为说明实现思路\n```tsx\n// define clip plane\nconst a = 0;\nconst b = 0;\nconst c = 1;\nconst d = 0;\nconst plane = vec4.fromValues(a, b, c, d);\n\n// render model and clip\nthis.pipeline\n  .setMesh(this.mesh)\n  .bind(this.window)\n  .clear()\n  .update(this.control.projectMatrix, this.control.viewMatrix, modelMatrix, this.needRenderPlane, plane)\n  .render()\n  .unbind();\n\n// render back face and +1 if stencil test pass\nthis.gl.enable(this.gl.CULL_FACE);\nthis.gl.cullFace(this.gl.BACK);\nthis.gl.colorMask(false, false, false, false);\nthis.gl.depthMask(true);\nthis.gl.enable(this.gl.STENCIL_TEST);\nthis.gl.stencilFunc(this.gl.ALWAYS, 1, 0xFF);\nthis.gl.stencilMask(0xFF); // allow write value, keep value that inputs\nthis.gl.stencilOp(this.gl.INCR_WRAP, this.gl.INCR_WRAP, this.gl.INCR_WRAP);\nthis.pipeline\n  .setMesh(this.mesh)\n  .clear()\n  .update(this.control.projectMatrix, this.control.viewMatrix, modelMatrix, this.needRenderPlane, plane)\n  .render()\n\n// render front face and -1 if stencil test pass\nthis.gl.cullFace(this.gl.FRONT);\nthis.gl.colorMask(false, false, false, false);\nthis.gl.depthMask(false);\nthis.gl.stencilOp(this.gl.DECR_WRAP, this.gl.DECR_WRAP, this.gl.DECR_WRAP);\nthis.pipeline\n  .render()\n  .unbind();\n\n// render cliped pattern when stencil not equal to 0\nthis.gl.disable(this.gl.CULL_FACE);\nthis.gl.colorMask(true, true, true, true);\nthis.gl.depthMask(true);\nthis.gl.stencilFunc(this.gl.NOTEQUAL, 0, 0xFF);\nthis.gl.stencilOp(this.gl.ZERO, this.gl.ZERO, this.gl.ZERO);\nthis.planePipeline\n  .bind(this.window)\n  .update(this.control.projectMatrix, this.control.viewMatrix, vec3.fromValues(1, 0, 0))\n  .render()\n  .unbind()\n\nthis.gl.disable(this.gl.STENCIL_TEST);\n```\n之后只需要根据需求渲染图案即可。\n### 与OpenGL的差异\n在刨切方面，OpenGL 3.3之后的版本支持gl_ClipDistance，我们可以在顶点着色器进行裁剪，示例代码如下：\n```cpp\nglViewport(0, 0, m_window.GetWidth(), m_window.GetHeight());\nglClearColor(0.f, 0.f, 0.f, 1.f);\nglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\nglEnable(GL_DEPTH_TEST);\nglEnable(GL_BLEND);\n\nglm::mat4 modelMatrix{\nglm::rotate(glm::mat4(1.f), glm::pi<float>() + static_cast<float>(time), glm::vec3(0., 1., 0.))};\nglm::vec4 clipPlane{0.f, 0.f, 1.f, 0.f};\n\nglEnable(GL_CLIP_PLANE0); // enable clip plane\n\nm_shader.Bind();\nm_mesh.Bind();\n\nm_shader.UpdateModelMatrix(modelMatrix)\n    .UpdateViewMatrix(m_control.GetViewMatrix())\n    .UpdateProjectionMatrix(m_control.GetProjectionMatrix())\n    .UpdateClipPlane(clipPlane);\n\nm_mesh.Render().UnBind();\nm_shader.UnBind();\n\nglDisable(GL_CLIP_PLANE0);\nglDisable(GL_DEPTH_TEST);\nglDisable(GL_BLEND);\n```\n在顶点着色器进行裁剪\n```glsl\n#version 300 es\n\nlayout(location=0)in vec3 a_position;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_viewMatrix;\nuniform mat4 u_modelMatrix;\nuniform vec4 u_plane;\n\nout vec3 v_pos;\n\nvoid main(){\n    gl_ClipDistance[0] = dot(u_plane, u_modelMatrix*vec4(a_position,1.f)); // clip plane\n    v_pos=(u_modelMatrix*vec4(a_position,1.)).xyz;\n    gl_Position=u_projectionMatrix*u_viewMatrix*u_modelMatrix*vec4(a_position,1.f);\n}\n\n```\n## TODO：添加边框线\n## 参考：\n【1】[https://ogldev.org/www/tutorial40/tutorial40.html](https://ogldev.org/www/tutorial40/tutorial40.html)  \n【2】[https://github.com/gkjohnson/three-mesh-bvh](https://github.com/gkjohnson/three-mesh-bvh)  \n【3】[http://www.it.hiof.no/~borres/j3d/math/plan/p-plan.html](http://www.it.hiof.no/~borres/j3d/math/plan/p-plan.html)  \n【4】[http://kjwy.5any.com/gdsx22/content/ch01/gdsx070502.htm](http://kjwy.5any.com/gdsx22/content/ch01/gdsx070502.htm)  \n【5】[https://prideout.net/clip-planes](https://prideout.net/clip-planes)  \n","date":"2023-6-24","profile":"https://cdn.nlark.com/yuque/0/2023/png/34898159/1686819652220-fd846fc8-27ee-4e30-b886-3f369954e937.png"},{"id":2,"title":"渲染篇-基于几何着色器实现边框线","content":"## 最终效果图：\n![](https://github.com/Eric-Schecter/wireframe-demo/blob/master/profiles/profile.png?raw=true#from=url&id=dfKt5&originHeight=891&originWidth=1132&originalType=binary&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&title=)\n## 背景说明\n在边框线的实现中，webgl基于重心坐标系在共享顶点数据的情况下无法正确分配权重值，对使用场景存在一定限制。针对这一问题，本文档说明基于opengl的几何着色器分配重心坐标系权重，以及计算点到各边距离两种解决方案。  \nGithub : [https://github.com/Eric-Schecter/wireframe-demo](https://github.com/Eric-Schecter/wireframe-demo)  \n## 几何着色器\n在传统的渲染管线中，我们可以通过顶点着色器和片元着色器，分别对每个顶点和每个片元进行数据处理。在OpenGL 3.2版本以后出现了几何着色器，是介于顶点着色器和片元着色器之间的可选阶段，有两个最主要的特点：  \n\n1. 对每个图元进行处理\n2. 可以改变输出的图元类型\n\n在边框线实现中，我们通过几何着色器，可以结合图元装配的各顶点数据，使得更多算法实现成为可能。\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1678072935838-0043b1b0-a238-4cef-94b0-3184d518dc4d.png#averageHue=%23c1c1c1&clientId=uabbb9a8e-94f3-4&from=paste&height=551&id=udf87df4e&originHeight=827&originWidth=1412&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=373853&status=done&style=none&taskId=u7f59d6bb-d826-49b0-a1e1-2585b726f71&title=&width=941.3333333333334)\n## 基于重心坐标系\n在之前边框线实现中，我们借由顶点数据传入重心坐标系权重值，经由渲染管线插值处理，得到距离三角面片各边的距离。该方法在共享顶点数据的绘制方法中存在限制，无法正确的分配各个顶点的重心权重值。  \n但是在几何着色器中，数据是以图元为单位进行处理，因此即使在共享顶点数据的情况下，我们依旧可以正确分配权重值。\n以下为几何着色器的代码，针对三个顶点分别分配不同的权重值即可：\n```glsl\n#version 460\n\nlayout(triangles) in;\nlayout(triangle_strip, max_vertices = 3) out;\n\nin gl_PerVertex\n{\n  vec4 gl_Position;\n  float gl_PointSize;\n  float gl_ClipDistance[];\n}gl_in[];  \n\nout gl_PerVertex {\n  vec4 gl_Position;\n  float gl_PointSize;\n  float gl_ClipDistance[];\n};\n\nout GS_FS_INTERFACE\n{\n  vec3 barycentric;\n} my_gs_out;\n\nvoid main(){\n\tfor(int i =0;i<gl_in.length();i++){\n\t\tgl_Position =gl_in[i].gl_Position;\n\t\tmy_gs_out.barycentric = vec3(i%3== 0 ? 1 : 0,i%3==1 ? 1 : 0,i%3==2 ? 1 : 0);\n\t\tEmitVertex();\n\t}\n\tEndPrimitive();\n}\n```\n## 基于点到各边距离\n在上述方法中，我们在片元着色器中拿到经过插值处理的重心权重值，进行点离各边距离判断。  \n借助几何着色器，我们可以直接传递点到各边的距离，在片元着色器中判断各边距离最小值是否小于线宽进行着色。  \n基本思路是：  \n\n1. 计算图元三角形面积  \n2. 计算顶点所对边长度  \n3. 计算顶点离对边距离  \n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1678508319365-5c918db4-0e11-4621-a198-53ca4b1b4a07.png#averageHue=%23f9f9f9&clientId=ua7e93110-578f-4&from=paste&id=uc4fa6f56&originHeight=933&originWidth=1050&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=176732&status=done&style=none&taskId=u89af006e-7362-46e4-8f22-d772a421950&title=)\n\n以下为基于世界空间计算的几何着色器部分代码\n```glsl\nout GS_FS_INTERFACE\n{\n  vec3 dist;\n} my_gs_out;\n\nvoid main(){\n\tvec3 p0 = gl_in[0].gl_Position.xyz;\n\tvec3 p1 = gl_in[1].gl_Position.xyz;\n\tvec3 p2 = gl_in[2].gl_Position.xyz;\n\n\tvec3 edge0 = p2 - p1;\n\tvec3 edge1 = p2 - p0;\n\tvec3 edge2 = p1 - p0;\n\n\tfloat area = length(cross(edge0,edge1));\n\n\tfor(int i =0;i<gl_in.length();i++){\n\t\tgl_Position =gl_in[i].gl_Position;\n\t\tmy_gs_out.dist = vec3(\n\t\t\ti%3==0 ? area/length(edge0) : 0,\n\t\t\ti%3==1 ? area/length(edge1) : 0,\n\t\t\ti%3==2 ? area/length(edge2) : 0\n\t\t);\n\t\tEmitVertex();\n\t}\n\n\tEndPrimitive();\n}\n```\n\n以下为NDC空间计算的几何着色器部分代码\n```glsl\nout GS_FS_INTERFACE\n{\n  vec3 dist;\n} my_gs_out;\n\nvoid main(){\n\tvec2 p0 = gl_in[0].gl_Position.xy/gl_in[0].gl_Position.w;\n\tvec2 p1 = gl_in[1].gl_Position.xy/gl_in[1].gl_Position.w;\n\tvec2 p2 = gl_in[2].gl_Position.xy/gl_in[2].gl_Position.w;\n\n\tvec2 edge0 = p2 - p1;\n\tvec2 edge1 = p2 - p0;\n\tvec2 edge2 = p1 - p0;\n\n\t// shoelace formula\n\tfloat area = abs(edge0.x*edge1.y-edge0.y*edge1.x);\n\n\tfor(int i =0;i<gl_in.length();i++){\n\t\tgl_Position =gl_in[i].gl_Position;\n\t\tmy_gs_out.dist = vec3(\n\t\t\ti%3==0 ? area/length(edge0) * gl_in[i].gl_Position.w : 0,\n\t\t\ti%3==1 ? area/length(edge1) * gl_in[i].gl_Position.w : 0,\n\t\t\ti%3==2 ? area/length(edge2) * gl_in[i].gl_Position.w : 0\n\t\t);\n\t\tEmitVertex();\n\t}\n\n\tEndPrimitive();\n}\n```\n\n以下为fragment shader部分代码\n```glsl\n#version 460\n\nin GS_FS_INTERFACE\n{\n  vec3 dist;\n} fs_in;\n\nconst vec3 color = vec3(1.f,0.64f,0.f);\n\nout vec4 fColor;\n\nvoid main() {\n    float minDis = min(fs_in.dist.x, min(fs_in.dist.y, fs_in.dist.z));\n    fColor = vec4(color, 1.f - minDis);\n} \n\n```\n## 参考：\n【1】[https://edom18.medium.com/how-to-make-a-wire-frame-shader-3c2ad67ec59](https://edom18.medium.com/how-to-make-a-wire-frame-shader-3c2ad67ec59)  \n【2】OpenGL编程指南（第9版）  \n","date":"2023-6-24","profile":"https://cdn.nlark.com/yuque/0/2023/png/34898159/1678072935838-0043b1b0-a238-4cef-94b0-3184d518dc4d.png"},{"id":3,"title":"渲染篇-粒子效果-基于transform feedback","content":"## 最终效果图：\n![profile.gif](https://cdn.nlark.com/yuque/0/2023/gif/34898159/1675322994541-2708683b-22c9-480d-a21d-1b15fd712ced.gif#averageHue=%23000100&clientId=u8793c2e8-68fb-4&from=paste&height=492&id=u579abb7c&originHeight=582&originWidth=1000&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5120216&status=done&style=none&taskId=u279b6680-f632-4f32-80dd-0acab92ab25&title=&width=844.6666870117188)\nGithub: [https://github.com/Eric-Schecter/particles-demo](https://github.com/Eric-Schecter/particles-demo)  \nDemo: [https://simple-particles-demo.netlify.app/](https://simple-particles-demo.netlify.app/)\n## 项目说明\n粒子效果是非常有趣的渲染效果，借助于GPU的加速计算，使得实时交互变为可能。\n本Demo主要基于WebGL的transform feedback实现粒子交互效果。\n技术栈：React，WebGL，gl-matrix\n除了transform feedback，还可以基于framebuffer以纹理为计算结果存储的解决方案，如Threejs中的GPUComputationRenderer  \n以下是基于Threejs中GPUComputationRenderer的粒子系统Demo  \n[https://music-visualizer-project.netlify.app/](https://music-visualizer-project.netlify.app/) 音乐可视化播放器  \n[https://arknights-particle.netlify.app/](https://arknights-particle.netlify.app/) 借鉴于曾今出现在明日方舟官网上的粒子效果\n\n## 实现原理\nWebGL 渲染管线有两个主要阶段，分别为vertex stage和fragment stage，当顶点数据提交给GPU后，一般我们会在fragment stage之后获取到数据，用于渲染或者计算。\nTransform feedback提供了在vertex stage之后提前获取数据的途径（WebGL没有geometry stage），相对于走完整个渲染管线的计算方式会有一定的性能提升。\n![](https://cdn.nlark.com/yuque/0/2023/jpeg/34898159/1675323613732-36d4b350-d907-4739-a8be-4f68bf6671c4.jpeg#averageHue=%2340f440&clientId=u8793c2e8-68fb-4&from=paste&height=439&id=u97b4e47b&originHeight=850&originWidth=650&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u41d1c25c-3e22-42db-8a11-ed61e798a00&title=&width=336)\n图片来源[ogldev.org](https://ogldev.org/)\n## 实现步骤\n首先我们需要准备两个program，一个用于更新position，一个用于渲染粒子\n我们从编写shader开始，计算过程都是在顶点阶段，传入position和velocity顶点数据，还有鼠标的指针位置作为粒子聚集的目标点位，经过计算后输出结果。（计算方式仅供参考）\n```glsl\n#version 300 es\n\nlayout(location=0)in vec3 a_position;\nlayout(location=1)in vec3 a_velocity;\n\nuniform vec2 u_target;\n\nout vec3 newPosition;\nout vec3 newVelocity;\n\nvoid main(){\n  vec3 target = vec3(u_target,0.);\n  float dis = distance(a_position,target);\n  vec3 dir = normalize(target - a_position);\n  float ratio = 0.01;\n  vec3 velocity = a_velocity + dir/dis * ratio;\n  vec3 position = a_position + velocity;\n  newPosition=position;\n  newVelocity=velocity;\n}\n\n```\n我们不需要片段阶段，因此保持最少的代码。\n```glsl\n#version 300 es\n\nprecision mediump float;\n\nvoid main(){\n}\n\n```\n由于要使用更新后的数据，我们需要做两件事\n\n1. 对program的创建逻辑添加transformfeedback的支持，指定我们需要输出的变量名，在这里为“newPosition”和“newVelocity”\n```typescript\nconst program = throwErrorIfInvalid(gl.createProgram());\n\nconst vertexShader = this.createShader(gl, gl.VERTEX_SHADER, vs);\nconst fragmentShader = this.createShader(gl, gl.FRAGMENT_SHADER, fs);\n\ngl.attachShader(program, vertexShader);\ngl.attachShader(program, fragmentShader);\nif(varyings.length){\n  // add this line to enable transform feedback when creating program\n  // pass output variables' name as varyings here\n  gl.transformFeedbackVaryings(program,varyings,gl.SEPARATE_ATTRIBS); \n}\n\ngl.linkProgram(program);\n\nif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n  const info = gl.getProgramInfoLog(program);\n  throw Error(`Could not compile WebGL program. \\n\\n${info}`);\n}\n```\n\n2. 添加创建transform feedback的方法\n```typescript\n// create transform feedback\nconst tf = this.gl.createTransformFeedback() as WebGLTransformFeedback;\n// bind transform feedback\nthis.gl.bindTransformFeedback(this.gl.TRANSFORM_FEEDBACK, tf);\n\n// create buffer to optain results\nthis.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer1);\nthis.gl.bindBufferBase(this.gl.TRANSFORM_FEEDBACK_BUFFER, 0, buffer1);\nthis.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer2);\nthis.gl.bindBufferBase(this.gl.TRANSFORM_FEEDBACK_BUFFER, 1, buffer2);\n\n// unbind transform feedback\nthis.gl.bindTransformFeedback(this.gl.TRANSFORM_FEEDBACK, null);\nthis.gl.bindBuffer(this.gl.ARRAY_BUFFER, null); // very important\n```\n由于需要做pingpong更新，我们准备两组buffers/transfrom feedback/vao分别用于读取和写入。\n\n以上是setup阶段，接下来是update阶段\n数据更新阶段是传统的pingpong更新方式，读取A写入B，再交换A与B，之后进行渲染。\n```typescript\nconst { clientWidth, clientHeight } = this.canvas;\nthis.gl.viewport(0, 0, clientWidth, clientHeight);\n\nthis.gl.clearColor(0, 0, 0, 1);\nthis.gl.clear(this.gl.COLOR_BUFFER_BIT);\n\n// update position\nthis.gl.enable(this.gl.RASTERIZER_DISCARD);\nthis.gl.useProgram(this.position);\nthis.gl.uniform2fv(this.targetLoc, [this.pointer[0], this.pointer[1]]);\nthis.gl.bindVertexArray(this.vaoPos[this.index % this.vaoPos.length]);\nthis.gl.bindTransformFeedback(this.gl.TRANSFORM_FEEDBACK, this.tfs[(this.index + 1) % this.vaoPos.length]);\nthis.gl.beginTransformFeedback(this.gl.POINTS);\nthis.gl.drawArrays(this.gl.POINTS, 0, this.particleCount);\nthis.gl.endTransformFeedback();\nthis.gl.bindTransformFeedback(this.gl.TRANSFORM_FEEDBACK, null);\nthis.gl.disable(this.gl.RASTERIZER_DISCARD);\n\n// draw particles\nthis.gl.useProgram(this.ps);\nthis.gl.bindVertexArray(this.vaoPos[(this.index + 1) % this.vaoPos.length]);\nthis.gl.drawArrays(this.gl.POINTS, 0, this.particleCount);\n\nthis.gl.bindVertexArray(null);\nthis.gl.useProgram(null);\n\nthis.index++;\n```\n\n到此基本结束，为了给渲染加点润色，我将方格像素换成圆，再结合屏幕位置变换颜色，shader代码如下：\n```glsl\n#version 300 es\n\nlayout(location=0)in vec3 a_position;\n\nout vec3 v_position;\n\nvoid main(){\n  gl_Position=vec4(a_position,1.f);\n  v_position = a_position;\n  gl_PointSize = 4.;\n}\n\n```\n```glsl\n#version 300 es\n\nprecision mediump float;\n\nuniform vec2 u_resolution;\n\nout vec4 fColor;\n\nvoid main(){  \n  vec2 uv = gl_PointCoord.xy;\n  vec2 color = gl_FragCoord.xy/u_resolution;\n  if(length(uv - vec2(0.5))>.5){\n    discard;\n  }\n  fColor=vec4(color,1.,1.);\n}\n\n```\n## 参考：\n[1] [https://webgl2fundamentals.org/webgl/lessons/webgl-gpgpu.html](https://webgl2fundamentals.org/webgl/lessons/webgl-gpgpu.html)  \n","date":"2023-6-24","profile":"https://cdn.nlark.com/yuque/0/2023/gif/34898159/1675322994541-2708683b-22c9-480d-a21d-1b15fd712ced.gif"},{"id":4,"title":"算法篇-牛顿迭代法","content":"### 故事的起源——为了彼此相遇\n当我们需要求解两条曲线的交点时，会转化为联立两个方程求解。\n以解基本椭圆方程为例：\n```\nx * x / (a1 * a1) + y * y / (b1 * b1) = 1 椭圆方程1\nx * x / (a2 * a2) + y * y / (b2 * b2) = 1 椭圆方程2\n设 c = (a2 * a2 - a1 * a1) * (b1 * b1 * b2 * b2)/(a2 * a2 * b1 * b1 - a1 * a1 * b2 * b2)；\n若 c < 0, 无解\n若 c >= 0, 有解\ny = Math.sqrt(((a2 * a2 - a1 * a1) * (b1 * b1 * b2 * b2)) / (a2 * a2 * b1 * b1 - a1 * a1 * b2 * b2));\nx = Math.sqrt((a1 * a1 * b1 * b1 - a1 * a1 * y * y)/(b1 * b1));\n```\n最终我们能够得到x和y的表达式，将已经量代入求解，我们可以得到交点的情况。\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1680247220532-908d8b83-9fb6-4e7c-9f22-10756aa9a968.png#averageHue=%23ededed&clientId=uae31ef11-aec9-4&from=paste&height=353&id=u80affc4f&originHeight=529&originWidth=628&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=30395&status=done&style=none&taskId=u1c7ffbb2-8e6f-4c69-9203-a5430f21927&title=&width=418.6666666666667)\n交点可视化\n上面的例子我们通过代入消元法得到十分友好的表达式，但在有些情况代入法可能会使问题变得十分复杂。如两带位移和旋转的椭圆相交问题：\n![](https://cdn.nlark.com/yuque/0/2023/gif/34898159/1680248412755-28bc8814-9306-4030-b009-d371cab2ed9f.gif#averageHue=%23e8e8e8&clientId=uae31ef11-aec9-4&from=paste&id=uc40a3100&originHeight=24&originWidth=352&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u1d6872cb-3216-4972-a846-1f3ddd6fca2&title=)\n联立两个上述方程代入消元，会面临一元四次方程的求解，很难得到最终的表达式。\n### 数值解与解析解——当你不再追求完美\n在解方程中，我们会考虑数值解或解析解，相关定义如下：\n解析解：通过解方程得到的精确解\n数值解：通过不断逼近得到的近似解\n\n以求算术平方根为例\n题目：给你一个非负整数 x ，计算并返回 x 的 算术平方根 \n```javascript\nvar mySqrt = function(x) {\n    let left = 0;\n    let right = x;\n    let ans = 0;\n    while(left<=right){\n        const mid = left + Math.floor((right-left)/2);\n        if(mid*mid<=x){\n            left = mid+1;\n            ans = mid;\n        }else{\n            right = mid-1;\n        }\n    }\n    return ans;\n};\n```\n通过二分法不断地迭代，即使我们没有算术平方根的表达式，也可以得到近似解。\n### 更快的结合——有一位媒人叫牛顿\n相比于二分法，牛顿迭代法具有更快的迭代速度。\n原因是：牛顿迭代法是基于切线逼近求解\n还是以求算术平方根为例，求sqrt(x)，为了可视化，我们的目标是用交点呈现要求的解，因此改变一下方程：\ny=x^2−c\n则当y=0时，c的平方根为方程的解。\n从图中可知，方程的解等价于曲线与x轴的交点的x坐标值。\n\n当我们取x=x0，则曲线上的点为（x0，x0^2-c）\n根据曲线的斜率方程 f′(x0)=2x0 ，得出与该点相切的直线方程：\ny = 2x0(x-x0) + x0^2 -c \n令y=0，得出\nx=0.5 * (x0+C/x0)\n在图形上表现为垂直于x轴的直线，以该直线与曲线交点再次求切线，不断重复上述过程，逼近交点值。\n以下为两次迭代的示意图，当迭代的差距很小时，我们得出近似解。\n[https://www.desmos.com/calculator/vj8gyu0lqi](https://www.desmos.com/calculator/vj8gyu0lqi) —— 可以改变数值体验\n![1.gif](https://cdn.nlark.com/yuque/0/2023/gif/34898159/1680252838138-52f58b9f-3463-47b3-9595-6febe203faa2.gif#averageHue=%23fbfafa&clientId=uae31ef11-aec9-4&from=paste&height=962&id=u07ea5863&originHeight=1443&originWidth=2547&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=1433597&status=done&style=none&taskId=u6892a00d-3eb3-44c3-88a5-9557bebd26e&title=&width=1698)\n\n根据上述思路，我们得出以下求解过程\n```javascript\nvar mySqrt = function(x) {\n    if(x === 0){\n        return 0;\n    }\n    let c = x;\n    let x0 = x;\n    while(true){\n        xi = 0.5 * (x0 + c/x0); \n        if(x0-xi < 1e-7){ // 当迭代差距小于阈值，得到目标值\n            break;\n        }\n        x0 = xi;\n    }\n    return x0;\n};\n```\n当不断迭代过程中，前后两次迭代差距小于阈值（1e-7），则说明我们已经逼近目标值，得出结果。\n### 泰勒展开式——当你发现媒人的吸引力\n上述求解我们通过图形可视化推导牛顿迭代法。\n在数学上，牛顿迭代法的理论基础源于泰勒展开式。\n泰勒展开式是用于将复杂函数拆解成无数个简单函数求和的方法。\n泰勒展开式的定义如下：设f(x)是一个连续可导函数，x0是它的近似零点，则在x0处的泰勒展开式为：\nf(x)=f(x0)+f'(x0)(x-x0)+0.5 * f'(x0)(x-x0)^2+...\n我们取一阶泰勒展开，得到\nf(x)=f(x0)+f'(x0)(x-x0)\n等价于上个例子中的\ny = 2x0(x-x0) + x0^2 -c \n其中，2x0为导数f'(x0)，x0^2 -c 为f(x)在x0的值。\n因此，牛顿迭代法在可视化中的表现是不断求切线逼近目标值，在数学上是不断地对方程做一阶泰勒展开趋近目标值的方法。\n### 求解一元二次方程——换种角度思考人生\n我们从数学的角度入手，尝试求解一元二次方程与x轴的交点：\nf(x)=x^2-2x-2\n首先对方程在x0处做一阶泰勒展开，根据公式：\nf(x)=f(x0)+f'(x0)(x-x0)\n得到：\nf(x) = x0^2-2x0-2 + (2x0-2)(x-x0)\nf(x) = 2(x0-1)x - (x0^2 + 2)\n令f(x) = 0，求解x，得到：\nx = (x0 ^ 2 + 2)/(2(x0 - 1))\n我们同样不断迭代，得到近似解，以下为两次迭代的示意图\n[https://www.desmos.com/calculator/ie6wag2ry6](https://www.desmos.com/calculator/ie6wag2ry6)\n![1.gif](https://cdn.nlark.com/yuque/0/2023/gif/34898159/1680797065037-ff9950d8-3d85-4f9e-9633-9d24561f2d27.gif#averageHue=%23f1f0f0&clientId=u81bdeacb-20e6-4&from=paste&height=962&id=udc4a6cb5&originHeight=1443&originWidth=2547&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=1724207&status=done&style=none&taskId=ue2ac39c8-3fb4-4e5a-99c5-284f4996eaf&title=&width=1698)\n\n在代码层面上，我们替换了新的迭代公式，同时去掉变量c。\n```javascript\nvar solveEquation = function(x) {\n    let x0 = x;\n    let xi = x;\n    while(true){\n        xi = (x0 ** 2 + 2)/(2*(x0 - 1)) // 迭代公式\n        if(x0-xi < 1e-7){ // 当迭代差距小于阈值，得到目标值\n            break;\n        }\n        x0 = xi;\n    }\n    return x0;\n};\n```\n当我们取x0为5时，得到的结果为2.732，非常接近图示的结果。\n### 求解二元二次方程组\n牛顿迭代法的关键是得到迭代公式，对于二元二次方程组，推导过程如下：\n设两方程分别为f(x,y)和g(x,y)，在(x0,y0)处一阶泰勒展开：\nf(x,y) = f(x0,y0) + fx(x0,y0)(x-x0) + fy(x0,y0)(y-y0)\ng(x,y) = g(x0,y0) + gx(x0,y0)(x-x0) + gy(x0,y0)(y-y0)\n其中fx，fy，gx，gy分别为对x，y的偏导数。\n令f(x,y) = 0，g(x,y) = 0，我们得出迭代公式：\n![](https://cdn.nlark.com/yuque/__latex/7f3dbe9ccb1c4a8dd573a5834e580780.svg#card=math&code=x%20%3D%20x0%20%2B%20%5Cfrac%7Bf%28x0%2Cy0%29gy%28x0%2Cy0%29%20-%20g%28x0%2Cy0%29fy%28x0%2Cy0%29%7D%7Bgx%28x0%2Cy0%29fy%28x0%2Cy0%29%20-%20fx%28x0%2Cy0%29gy%28x0%2Cy0%29%7D&id=VGlkJ)\n![](https://cdn.nlark.com/yuque/__latex/e483395bc916266b154d2f43786e6bbc.svg#card=math&code=y%20%3D%20y0%20%2B%20%5Cfrac%7Bg%28x0%2Cy0%29fx%28x0%2Cy0%29%20-%20f%28x0%2Cy0%29gx%28x0%2Cy0%29%7D%7Bgx%28x0%2Cy0%29fy%28x0%2Cy0%29%20-%20fx%28x0%2Cy0%29gy%28x0%2Cy0%29%7D&id=HBOHK)\n当分母 gx(x0,y0)fy(x0,y0) - fx(x0,y0)gy(x0,y0) != 0时成立。\n\n我们以求解两椭圆相交问题为例，设两椭圆为：\nx^2/a1^2 + y^2/b1^2 =1\nx^2/a2^2 + y^2/b2^2 =1\n我们得到\nf(x,y) = x^2/a1^2 + y^2/b1^2 - 1\ng(x,y) = x^2/a2^2 + y^2/b2^2 - 1\n根据上述迭代方程，我们得到：\n![](https://cdn.nlark.com/yuque/__latex/b43ae406214ac89ae23ebc428b97070d.svg#card=math&code=x_%7B1%7D%20%3D%20x_%7B0%7D%20%2B%20%5Cfrac%7B%28%5Cfrac%7Bx_%7B0%7D%5E2%7D%7Ba_%7B1%7D%5E2%7D%20%2B%20%5Cfrac%7By_%7B0%7D%5E2%7D%7Bb_%7B1%7D%5E2%20%7D%20-%201%29%2A%5Cfrac%7B2%20%2Ay_%7B0%7D%7D%7Bb_%7B2%7D%5E2%7D%20-%20%28%5Cfrac%7Bx_%7B0%7D%5E2%7D%7Ba_%7B2%7D%5E2%7D%20%2B%20%5Cfrac%7By_%7B0%7D%5E2%7D%7Bb_%7B2%7D%5E2%7D%20-%201%29%20%2A%20%5Cfrac%7B2%2Ay_%7B0%7D%7D%7Bb_%7B1%7D%5E2%7D%7D%7B%5Cfrac%7B2%20%2A%20x_%7B0%7D%7D%7Ba_%7B2%7D%5E2%7D%20%2A%20%5Cfrac%7B2%20%2A%20y_%7B0%7D%7D%7Bb_%7B1%7D%5E2%7D%20-%20%5Cfrac%7B2%20%2A%20x_%7B0%7D%7D%7Ba_%7B1%7D%5E2%7D%20%2A%20%5Cfrac%7B2%20%2A%20y_%7B0%7D%7D%7Bb_%7B2%7D%20%5E2%7D%7D&id=Fv45u)\n![](https://cdn.nlark.com/yuque/__latex/2e541d479c575b484e256cbb628dd35c.svg#card=math&code=y_%7B1%7D%20%3D%20y_%7B0%7D%20%2B%20%5Cfrac%7B%28%5Cfrac%7Bx_%7B0%7D%5E2%7D%7Ba_%7B2%7D%5E2%7D%20%2B%20%5Cfrac%7By_%7B0%7D%5E2%7D%7Bb_%7B2%7D%5E2%20%7D%20-%201%29%2A%5Cfrac%7B2%20%2Ax_%7B0%7D%7D%7Ba_%7B1%7D%5E2%7D%20-%20%28%5Cfrac%7Bx_%7B0%7D%5E2%7D%7Ba_%7B1%7D%5E2%7D%20%2B%20%5Cfrac%7By_%7B0%7D%5E2%7D%7Bb_%7B1%7D%5E2%7D%20-%201%29%20%2A%20%5Cfrac%7B2%2Ax_%7B0%7D%7D%7Ba_%7B2%7D%5E2%7D%7D%7B%5Cfrac%7B2%20%2A%20x_%7B0%7D%7D%7Ba_%7B2%7D%5E2%7D%20%2A%20%5Cfrac%7B2%20%2A%20y_%7B0%7D%7D%7Bb_%7B1%7D%5E2%7D%20-%20%5Cfrac%7B2%20%2A%20x_%7B0%7D%7D%7Ba_%7B1%7D%5E2%7D%20%2A%20%5Cfrac%7B2%20%2A%20y_%7B0%7D%7D%7Bb_%7B2%7D%20%5E2%7D%7D&id=DafLo)\n当![](https://cdn.nlark.com/yuque/__latex/311497ca30f0d58d2ada660145ca9ae7.svg#card=math&code=%5Cfrac%7B2%20%2A%20x_%7B0%7D%7D%7Ba_%7B2%7D%5E2%7D%20%2A%20%5Cfrac%7B2%20%2A%20y_%7B0%7D%7D%7Bb_%7B1%7D%5E2%7D%20-%20%5Cfrac%7B2%20%2A%20x_%7B0%7D%7D%7Ba_%7B1%7D%5E2%7D%20%2A%20%5Cfrac%7B2%20%2A%20y_%7B0%7D%7D%7Bb_%7B2%7D%20%5E2%7D&id=Ff3oV)!= 0 时，等式成立\n\n之后不断迭代，知道前后位置距离小于阈值，得出结果。\n### 雅可比矩阵与海森矩阵——多元的泰勒展开\n一元函数的泰勒展开：\n![](https://cdn.nlark.com/yuque/0/2023/svg/34898159/1680747269248-ed2944f1-8ad7-41b7-914a-354b0cf77634.svg#clientId=u0e9a0919-4427-4&from=paste&id=uc765e4e9&originHeight=88&originWidth=395&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u969df749-c949-4ce3-8adf-c45a1dca62e&title=)\n二元函数的泰勒展开：\n![](https://cdn.nlark.com/yuque/0/2023/svg/34898159/1680747432444-ef3cb457-51bb-4621-83c6-25b8a4cbb451.svg#clientId=u0e9a0919-4427-4&from=paste&id=u58fb650c&originHeight=88&originWidth=686&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u22650534-5540-4d4f-9118-d9f3eba4578&title=)\n随着变量及阶数的增加，表达式会越来越长，因此可以改写成矩阵形式简化表达式：\n以二元函数的泰勒展开为例：\n![](https://cdn.nlark.com/yuque/0/2023/svg/34898159/1680747538630-319332e0-1eab-4a3c-b09d-034a51618097.svg#clientId=u0e9a0919-4427-4&from=paste&id=uaf70c103&originHeight=113&originWidth=485&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u6d4619aa-7a36-4083-b325-569dd4cc81e&title=)\n其中一阶偏导数矩阵为雅可比矩阵，二阶偏导数矩阵为海森矩阵。\n海森矩阵是方阵，而雅可比矩阵则不一定。\n\n## 参考：\n[1] [https://leetcode.cn/problems/sqrtx/description/](https://leetcode.cn/problems/sqrtx/description/)  \n[2] [https://wenku.baidu.com/view/cac8012db4daa58da0114ae8.html?_wkts_=1680755886597](https://wenku.baidu.com/view/cac8012db4daa58da0114ae8.html?_wkts_=1680755886597)  \n","date":"2023-6-24","profile":"https://cdn.nlark.com/yuque/0/2023/png/34898159/1680247220532-908d8b83-9fb6-4e7c-9f22-10756aa9a968.png"},{"id":1,"title":"渲染篇-基于shader实现边框线","content":"## 最终效果图：\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1677032886101-924d0265-30c2-4c81-89f4-c9f8ab9e8a9d.png#averageHue=%23eeecea&clientId=u23331aff-86eb-4&from=paste&height=281&id=u312b28d2&name=image.png&originHeight=421&originWidth=599&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=30054&status=done&style=none&taskId=ud609bdc2-4577-4cf9-ac01-92947e1e558&title=&width=399.3333333333333)\n## 背景说明\n在Threejs当中，Mesh的边框是由gl.Lines方式绘制，为了不改变图元绘制方式，本文档说明如何通过shader实现边框着色的效果。\n以下为初始的样本。\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1677040308705-8ee82d85-953f-4f42-81f2-75227261651e.png#averageHue=%23eee6db&clientId=u23331aff-86eb-4&from=paste&height=344&id=u15037f64&name=image.png&originHeight=516&originWidth=712&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=6132&status=done&style=none&taskId=uf926adb4-4ba7-46d3-ae12-83ad6da2e2b&title=&width=474.6666666666667)\n## 重心坐标系——靠近边缘的判定方法\n在光栅化算法实现中，传入片段着色器中的顶点数据，是基于图元装配的类型，经由光栅化的线性插值计算得出。  \n重心坐标系作为一种权重表达，为插值计算提供简单便利的实现，以得出三角形内任一点的顶点数据，也是该方案实现的核心。  \n在重心坐标系中的任意点P可用以下公式表示：\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1677158237228-4786e5e0-c246-4610-af33-ac0190348995.png#averageHue=%23faf9f8&clientId=u1ec16aa9-7fc7-4&from=paste&height=41&id=ue87ef609&name=image.png&originHeight=61&originWidth=469&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=6440&status=done&style=none&taskId=u92fc146a-fb80-4734-b64c-effbd4684f6&title=&width=312.6666666666667)\n其中V0、V1、V2为顶点数据，$\\lambda_0$、 $\\lambda_1$、$\\lambda_2$为权重，P为三角形内任意点。  \n在这里我们设置三个顶点数据为V0=vec3(1,0,0)，V1=vec3(0,1,0)，V2=vec3(0,0,1)，并将其可视化会得到如下结果。\n![](https://cdn.nlark.com/yuque/0/2023/png/34898159/1677035484106-4652d128-ad6a-4145-8f66-9b8e6cf7d81e.png#averageHue=%23f1edea&clientId=u23331aff-86eb-4&from=paste&id=u6e6ffc6c&originHeight=245&originWidth=300&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u20c338a3-be54-478c-bb87-8a25b4b93fe&title=)\n在极限状态下，例如P位于V0处，此时权重系数$\\lambda_0$为1，$\\lambda_1$和$\\lambda_2$为0，其他顶点同理。  \n换一种理解方式，权重系数表达了顶点对应的三角形面积占整个三角形的面积比例。\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1677157726790-6401ebdd-1e06-41ad-9da5-8b1296eed6e7.png#averageHue=%23fefafa&clientId=u85a016a3-f706-4&from=paste&height=183&id=u175d49c6&name=image.png&originHeight=275&originWidth=411&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=31773&status=done&style=none&taskId=ub67ff025-50d8-4075-a9bd-5260bb193fd&title=&width=274)\n![](https://cdn.nlark.com/yuque/0/2023/png/34898159/1677039603030-7c67f04b-79cd-44bf-ab10-d48fdb133d8b.png#averageHue=%234d4d4c&clientId=u23331aff-86eb-4&from=paste&id=u18e25b86&originHeight=245&originWidth=300&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u48f1c376-b1a7-49e8-981d-144452f3ec2&title=)\n\n因此我们得到结论：在重心坐标系中，P的任意一个系数小于阈值，代表其靠近其中一个边。  \n基于以上结论，我们写出边框着色shader的初版，基于计算出的alpha，得出边框着色的四方体\n```glsl\nvarying vec3 vBarycentric;\n\nfloat computeAlpha(vec3 barycentric){\n  float ratio = min(min(barycentric.x,barycentric.y),barycentric.z);\n  float threshold = 0.01;\n  return ratio < threshold ? 1. : 0.;\n}\n```\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1677033708563-e5892503-50a6-45d7-b45c-4682a8f10c35.png#averageHue=%23eeedeb&clientId=u23331aff-86eb-4&from=paste&height=331&id=ucfa95adc&name=image.png&originHeight=497&originWidth=576&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=20340&status=done&style=none&taskId=u67007020-eec2-4531-9460-4486ea24c6c&title=&width=384)\n## dfx,dfy,fwidth——抗锯齿\n在上面的例子中，我们通过重心坐标系画出边缘，但是出现了锯齿，这在程序纹理实现当中是普遍存在的现象。解决的方案，是不要基于单个点计算函数的值，需要结合周边点做均值以缓解失真。\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1677043120668-fb5a4800-3a84-4254-a8bf-21d96bb2cd3e.png#averageHue=%238e8e8e&clientId=u23331aff-86eb-4&from=paste&height=307&id=uc1c5a670&name=image.png&originHeight=460&originWidth=893&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=207727&status=done&style=none&taskId=u3bfad413-6467-4311-844f-e7f70314122&title=&width=595.3333333333334)\ndfx和dfy函数，会基于屏幕空间的x和y方向，返回传入参数的近似偏导数。其具体实现方式会有所区别，但通常片段着色器会以2x2（称为四边形片段）进行光栅化，以支持偏导数的计算。  \nfwidth函数则会基于传入参数返回x和y方向的近似偏导数之和。  \n以传入参数为vec3为例\n```glsl\nvec3 fwidth(vec3 a)\n{\n  return abs(dfx(a)) + abs(dfy(a));\n}\n```\n换句话说，fwidth综合考虑了周围的数据，降低高频变化的影响。在我们的例子中，通过fwidth(barycentric)降低了权重系数的突变。  \n通过smoothstep（参考备注）函数，我们对barycentric做平滑处理，重新生成权重系数。\n```glsl\nvarying vec3 vBarycentric;\n\nfloat computeAlpha(vec3 barycentric){\n  vec3 d=fwidth(barycentric);\n  vec3 a3=smoothstep(vec3(0.),d,barycentric);\n  return mix(1.,0.,min(min(a3.x,a3.y),a3.z));\n}\n```\n最后，我们用d乘上线宽参数lineWidth，调节a3的变化速率，以达到减少/增加线宽的目的。\n```glsl\nvarying vec3 vBarycentric;\nconst float lineWidth = 1.;\n\nfloat computeAlpha(vec3 barycentric){\n  vec3 d=fwidth(barycentric);\n  vec3 a3=smoothstep(vec3(0.),d*lineWidth,barycentric);\n  return mix(1.,0.,min(min(a3.x,a3.y),a3.z));\n}\n```\n## 缺陷——无法共享顶点数据\n虽然该方案可以实现边框着色，但需要预先设置三角形各顶点的权重，因此对重心坐标的顶点数据生成有一定要求，在共享数据的绘制方法中（gl.drawElement）存在问题，在现阶段暂无解决方案。  \n如果基于几何着色器，可以结合图元装配所涉及的三个顶点计算距离来实现，无需借助重心坐标系，该方案会在下一篇文档进行讲解。（webgl无几何着色器）\n![](https://i.stack.imgur.com/ganU3.png#from=url&id=izlV2&originHeight=279&originWidth=511&originalType=binary&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&title=)\n## 备注——关于soomthstep函数\nsmoothstep函数可以返回0到1的平滑插值，该函数接收三个参数，分别为下限a、上限b和对比参考值x。  \n当x<a，返回0。  \n当x>b，返回1。  \n当a<x<b，基于x返回介于a和b之间的线性插值。\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1677048001574-735b18c7-34cc-4568-be0a-57fc1354b9ae.png#averageHue=%23fdfdfd&clientId=u23331aff-86eb-4&from=paste&height=309&id=NnQGW&name=image.png&originHeight=463&originWidth=1198&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=12713&status=done&style=none&taskId=u286371b1-4571-4fbe-8822-a4ff8aecf5d&title=&width=798.6666666666666)\n## 参考：\n【1】[https://developer.download.nvidia.com/cg/ddx.html](https://developer.download.nvidia.com/cg/ddx.html)  \n【2】[https://developer.download.nvidia.com/cg/ddy.html](https://developer.download.nvidia.com/cg/ddy.html)  \n【3】[https://developer.download.nvidia.com/cg/fwidth.html](https://developer.download.nvidia.com/cg/fwidth.html)   \n【4】[https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch25.html](https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch25.html)  \n【5】[https://stackoverflow.com/questions/24839857/wireframe-shader-issue-with-barycentric-coordinates-when-using-shared-vertices](https://stackoverflow.com/questions/24839857/wireframe-shader-issue-with-barycentric-coordinates-when-using-shared-vertices)  \n【6】[https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/rasterization-stage.html](https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/rasterization-stage.html)  \n","date":"2023-2-23","profile":"https://cdn.nlark.com/yuque/0/2023/png/34898159/1677032886101-924d0265-30c2-4c81-89f4-c9f8ab9e8a9d.png"}]