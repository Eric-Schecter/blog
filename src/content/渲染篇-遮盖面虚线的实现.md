## 最终效果图：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1687878370627-c8d79e2b-9b54-4821-ad8a-610e1f64c91d.png#averageHue=%23191919&clientId=uc5773fb1-b7f5-4&from=paste&height=820&id=ua67b8493&originHeight=1230&originWidth=1445&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=685006&status=done&style=none&taskId=uaa1649a3-2ea5-47ba-b86b-0c03c3b1056&title=&width=963.3333333333334)
## 背景说明
业务场景中需要实现的显示状态，表面为实现，背面遮挡为虚线，本文基于WebGL实现并尝试解释实现思路。  
Demo：[https://webgl-renderer.netlify.app/#/display-mode](https://webgl-renderer.netlify.app/#/display-mode)  
Github：  
WebGL：[https://github.com/Eric-Schecter/webgl-renderer](https://github.com/Eric-Schecter/webgl-renderer)  
## 基本思路
以表面深度作为判断基准，深度测试小于表面深度渲染实线，大于表面深度渲染虚线。  
首先渲染模型并禁用颜色写入，只渲染深度信息（代码仅供表达思路）  
```typescript
this.modelPipeline
  .setMesh(this.mesh)
  .bind(this.window)
  .clear()
  .disableColorMask()
  .update(this.control, white)
  .render()
  .enableColorMask()
```
之后渲染表面实线  
```typescript
this.gl.enable(this.gl.POLYGON_OFFSET_FILL); // 缓解z-fighting
this.gl.polygonOffset(1.0, 1.0);

this.modelPipeline
  .setMesh(this.lineMesh)
  .update(this.control, white)
  .render()
  .unbind();
```
最后渲染背面虚线，通过设置深度判断函数为gl.GREATER实现
```typescript
const dashGap = 10;
const dashSize = 10;

this.gl.depthFunc(this.gl.GREATER);

this.dashedlinePipeline
  .setMesh(this.lineMesh)
  .bind(this.window)
  .update(this.control, this.window, dashGap, dashSize, white, 0.5)
  .render()
  .unbind();

this.gl.depthFunc(this.gl.LEQUAL);
```

以下为渲染效果图，只渲染表面实线  
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1687879604211-a49efe74-f1b6-4899-88e6-853156ead647.png#averageHue=%230f0f0f&clientId=uc5773fb1-b7f5-4&from=paste&height=696&id=ubc834776&originHeight=1044&originWidth=1247&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=239839&status=done&style=none&taskId=u37f8c084-028b-4ddd-a0a4-17b752e2bd8&title=&width=831.3333333333334)
只渲染背面虚线  
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1687879667236-33c9984c-a40b-4200-ad7b-de0951d5ccea.png#averageHue=%23141414&clientId=uc5773fb1-b7f5-4&from=paste&height=774&id=ubb86a8e5&originHeight=1161&originWidth=1296&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=383357&status=done&style=none&taskId=u7d78b26b-72bc-447a-8395-5406d040923&title=&width=864)
将两者结合  
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1687878370627-c8d79e2b-9b54-4821-ad8a-610e1f64c91d.png#averageHue=%23191919&clientId=uc5773fb1-b7f5-4&from=paste&height=820&id=nDcYH&originHeight=1230&originWidth=1445&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=685006&status=done&style=none&taskId=uaa1649a3-2ea5-47ba-b86b-0c03c3b1056&title=&width=963.3333333333334)
## 关于虚线的实现
### 基本思路：
渲染虚线是在渲染实线的基础上，基于画线的两顶点距离进行切割，规律性的渲染一部分舍弃一部分实现的。  
关于计算两顶点距离，可以通过顶点数据传递（Threejs的实现方式），也可以在shader计算，以下为shader的实现方式。  
### 前置知识：flat限定符
默认情况下，数据由顶点着色器传递到片段着色器会做线性插值。如果在varying变量前设置flat限定符，则数据直接传递，不会做线性插值，这有助于在片段着色器画线时，计算渲染位置距离线段初始的距离。  
以下为虚线的shader代码实现：  
```glsl
#version 300 es

layout(location=0)in vec3 a_position;

uniform mat4 u_projectMatrix;
uniform mat4 u_viewMatrix;
uniform mat4 u_modelMatrix;

out vec3 v_pos;
flat out vec3 v_startPos;

// https://stackoverflow.com/questions/52928678/dashed-line-in-opengl3
void main(){
    v_pos=a_position;
    v_startPos=a_position;
    gl_Position=u_projectMatrix*u_viewMatrix*u_modelMatrix*vec4(a_position,1.f);
}

```
在片段着色器中，计算两点之间的距离时，乘上了窗口的尺寸u_resolution的一半。原因是经过渲染管线投影裁剪过后，v_pos和v_startPos被缩放到[-1,1]的范围。经过放大到窗口尺寸，以配合后续的虚线切割计算。  
```glsl
#version 300 es

precision mediump float;

uniform float u_alpha;
uniform vec2 u_resolution;
uniform float u_dashSize;
uniform float u_gapSize;
uniform vec3 u_color;

in vec3 v_pos;
flat in vec3 v_startPos;

out vec4 fColor;

void main(){
    vec2 dir=(v_pos.xy-v_startPos.xy)*u_resolution/2.;
    float dist=length(dir);
  
    if(fract(dist/(u_dashSize+u_gapSize))>(u_dashSize/(u_dashSize+u_gapSize))){
        discard;
    }
    
    fColor=vec4(u_color,u_alpha);
}

```

在Threejs中通过顶点数据，传递两顶点之间距离lineDistance，在片段着色器中通过mod运算将线段进行切割舍弃。根据图元绘制的方法（gl.Lines和gl.LineStrip）不同，lineDistance的计算有所差异，待后续补充。  
## 参考：
【1】[https://stackoverflow.com/questions/52928678/dashed-line-in-opengl3](https://stackoverflow.com/questions/52928678/dashed-line-in-opengl3)  
【2】[https://github.com/mrdoob/three.js/blob/master/src/geometries/WireframeGeometry.js](https://github.com/mrdoob/three.js/blob/master/src/geometries/WireframeGeometry.js)  
