## 最终效果图：
![](https://github.com/Eric-Schecter/wireframe-demo/blob/master/profiles/profile.png?raw=true#from=url&id=dfKt5&originHeight=891&originWidth=1132&originalType=binary&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&title=)
## 背景说明
在边框线的实现中，webgl基于重心坐标系在共享顶点数据的情况下无法正确分配权重值，对使用场景存在一定限制。针对这一问题，本文档说明基于opengl的几何着色器分配重心坐标系权重，以及计算点到各边距离两种解决方案。  
Github : [https://github.com/Eric-Schecter/wireframe-demo](https://github.com/Eric-Schecter/wireframe-demo)  
## 几何着色器
在传统的渲染管线中，我们可以通过顶点着色器和片元着色器，分别对每个顶点和每个片元进行数据处理。在OpenGL 3.2版本以后出现了几何着色器，是介于顶点着色器和片元着色器之间的可选阶段，有两个最主要的特点：  

1. 对每个图元进行处理
2. 可以改变输出的图元类型

在边框线实现中，我们通过几何着色器，可以结合图元装配的各顶点数据，使得更多算法实现成为可能。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1678072935838-0043b1b0-a238-4cef-94b0-3184d518dc4d.png#averageHue=%23c1c1c1&clientId=uabbb9a8e-94f3-4&from=paste&height=551&id=udf87df4e&originHeight=827&originWidth=1412&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=373853&status=done&style=none&taskId=u7f59d6bb-d826-49b0-a1e1-2585b726f71&title=&width=941.3333333333334)
## 基于重心坐标系
在之前边框线实现中，我们借由顶点数据传入重心坐标系权重值，经由渲染管线插值处理，得到距离三角面片各边的距离。该方法在共享顶点数据的绘制方法中存在限制，无法正确的分配各个顶点的重心权重值。  
但是在几何着色器中，数据是以图元为单位进行处理，因此即使在共享顶点数据的情况下，我们依旧可以正确分配权重值。
以下为几何着色器的代码，针对三个顶点分别分配不同的权重值即可：
```glsl
#version 460

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

in gl_PerVertex
{
  vec4 gl_Position;
  float gl_PointSize;
  float gl_ClipDistance[];
}gl_in[];  

out gl_PerVertex {
  vec4 gl_Position;
  float gl_PointSize;
  float gl_ClipDistance[];
};

out GS_FS_INTERFACE
{
  vec3 barycentric;
} my_gs_out;

void main(){
	for(int i =0;i<gl_in.length();i++){
		gl_Position =gl_in[i].gl_Position;
		my_gs_out.barycentric = vec3(i%3== 0 ? 1 : 0,i%3==1 ? 1 : 0,i%3==2 ? 1 : 0);
		EmitVertex();
	}
	EndPrimitive();
}
```
## 基于点到各边距离
在上述方法中，我们在片元着色器中拿到经过插值处理的重心权重值，进行点离各边距离判断。  
借助几何着色器，我们可以直接传递点到各边的距离，在片元着色器中判断各边距离最小值是否小于线宽进行着色。  
基本思路是：  

1. 计算图元三角形面积  
2. 计算顶点所对边长度  
3. 计算顶点离对边距离  

![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1678508319365-5c918db4-0e11-4621-a198-53ca4b1b4a07.png#averageHue=%23f9f9f9&clientId=ua7e93110-578f-4&from=paste&id=uc4fa6f56&originHeight=933&originWidth=1050&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=176732&status=done&style=none&taskId=u89af006e-7362-46e4-8f22-d772a421950&title=)

以下为基于世界空间计算的几何着色器部分代码
```glsl
out GS_FS_INTERFACE
{
  vec3 dist;
} my_gs_out;

void main(){
	vec3 p0 = gl_in[0].gl_Position.xyz;
	vec3 p1 = gl_in[1].gl_Position.xyz;
	vec3 p2 = gl_in[2].gl_Position.xyz;

	vec3 edge0 = p2 - p1;
	vec3 edge1 = p2 - p0;
	vec3 edge2 = p1 - p0;

	float area = length(cross(edge0,edge1));

	for(int i =0;i<gl_in.length();i++){
		gl_Position =gl_in[i].gl_Position;
		my_gs_out.dist = vec3(
			i%3==0 ? area/length(edge0) : 0,
			i%3==1 ? area/length(edge1) : 0,
			i%3==2 ? area/length(edge2) : 0
		);
		EmitVertex();
	}

	EndPrimitive();
}
```

以下为NDC空间计算的几何着色器部分代码
```glsl
out GS_FS_INTERFACE
{
  vec3 dist;
} my_gs_out;

void main(){
	vec2 p0 = gl_in[0].gl_Position.xy/gl_in[0].gl_Position.w;
	vec2 p1 = gl_in[1].gl_Position.xy/gl_in[1].gl_Position.w;
	vec2 p2 = gl_in[2].gl_Position.xy/gl_in[2].gl_Position.w;

	vec2 edge0 = p2 - p1;
	vec2 edge1 = p2 - p0;
	vec2 edge2 = p1 - p0;

	// shoelace formula
	float area = abs(edge0.x*edge1.y-edge0.y*edge1.x);

	for(int i =0;i<gl_in.length();i++){
		gl_Position =gl_in[i].gl_Position;
		my_gs_out.dist = vec3(
			i%3==0 ? area/length(edge0) * gl_in[i].gl_Position.w : 0,
			i%3==1 ? area/length(edge1) * gl_in[i].gl_Position.w : 0,
			i%3==2 ? area/length(edge2) * gl_in[i].gl_Position.w : 0
		);
		EmitVertex();
	}

	EndPrimitive();
}
```

以下为fragment shader部分代码
```glsl
#version 460

in GS_FS_INTERFACE
{
  vec3 dist;
} fs_in;

const vec3 color = vec3(1.f,0.64f,0.f);

out vec4 fColor;

void main() {
    float minDis = min(fs_in.dist.x, min(fs_in.dist.y, fs_in.dist.z));
    fColor = vec4(color, 1.f - minDis);
} 

```
## 参考：
【1】[https://edom18.medium.com/how-to-make-a-wire-frame-shader-3c2ad67ec59](https://edom18.medium.com/how-to-make-a-wire-frame-shader-3c2ad67ec59)  
【2】OpenGL编程指南（第9版）  
