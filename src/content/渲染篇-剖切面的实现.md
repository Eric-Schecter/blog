## 最终效果图：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1688205839242-7b9c9cea-dd2d-41b5-8bff-387a062ab7ec.png#averageHue=%23281f15&clientId=u02f3f154-a18e-4&from=paste&height=838&id=ua83ba1bf&originHeight=1257&originWidth=1407&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=574593&status=done&style=none&taskId=u961bfa2b-384f-4863-a6c6-b81f484f096&title=&width=938)
## 背景说明
业务场景中需要实现刨切面渲染效果，本文基于WebGL实现并尝试解释实现思路。
Demo：[https://webgl-renderer.netlify.app/#/clip-plane](https://webgl-renderer.netlify.app/#/clip-plane)  
Github：  
WebGL：[https://github.com/Eric-Schecter/webgl-renderer](https://github.com/Eric-Schecter/webgl-renderer)  
OpenGL：[https://github.com/Eric-Schecter/opengl-renderer](https://github.com/Eric-Schecter/opengl-renderer)  
### 原始模型
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1686837920587-7ed099db-2eae-4de8-94b3-6a7d6c41e91c.png#averageHue=%23cdf799&clientId=ub4cb5497-3b23-4&from=paste&height=925&id=u564fe52f&originHeight=1388&originWidth=1342&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=462634&status=done&style=none&taskId=u10b116a7-c6f6-4e1b-97bd-74d066b4ce5&title=&width=894.6666666666666)
## 原理解析
### 基于刨切面的裁剪
实现思路：在世界空间中构造一个虚拟平面，将模型分割成两部分。通过判断像素是否处于刨切面的一侧来选择保留或者舍弃。
#### 平面的构造：
已知平面的一般方程为：Ax+By+Cz+D=0
其中vec3(A,B,C)三个系数构成的向量为该平面的法向量，D为该平面到原点的距离。
基于以上结论，我们可以在世界空间中构造任意一个平面。
#### 模型与刨切面的位置判断：
我们设模型的世界位置信息为P(x0,y0,z0)，刨切面法线为N(A,B,C)。
将位置信息P与平面法线N做点积得到Ax0+By0+Cz0，代入上述的平面一般方程得到：
Ax0+By0+Cz0+D=0，等价于N · P + D =0
以为D代表平面到原点的距离，我们得到

- 如果 N · P + D > 0，表示点与平面法线同侧。
- 如果 N · P + D < 0，表示点与平面法线反侧。
- 如果 N · P + D = 0，表示点在平面上。

代码实现如下：
```glsl
#version 300 es

layout(location=0)in vec3 a_position;

uniform mat4 u_projectMatrix;
uniform mat4 u_viewMatrix;
uniform mat4 u_modelMatrix;

out vec3 v_pos;

void main(){
    v_pos=(u_modelMatrix*vec4(a_position,1.)).xyz; // get position in the world space
    gl_Position=u_projectMatrix*u_viewMatrix*u_modelMatrix*vec4(a_position,1.f);
}

```
```glsl
#version 300 es

precision mediump float;

uniform vec4 u_plane; // vec4(A,B,C,D)
uniform int u_needrenderplane;

in vec3 v_pos;

out vec4 f_color;

void main(){
    // judge whether mesh is in the clipping side
    if(u_needrenderplane==1&&dot(v_pos,u_plane.xyz)>u_plane.w){
        discard;
    }
    vec3 color=(v_pos+vec3(1.f))/2.f;
    f_color=vec4(color,1.);
}

```
裁剪效果如下
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1686838021230-fb72094a-bfb2-4de5-af5d-1d1f0d3de11b.png#averageHue=%230b0806&clientId=ub4cb5497-3b23-4&from=paste&height=800&id=ube59b353&originHeight=1200&originWidth=1171&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=216086&status=done&style=none&taskId=u135bcf15-e811-4212-9020-b43df955b3a&title=&width=780.6666666666666)
### 刨切面的绘制
任何封闭的物体都有正反两面的像素信息，如下图所示，左立方体为正面，右立方体为背面。
当物体被刨切时，会缺少正面的像素信息，正是我们需要着色的区域。  
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1686839848903-5d168a46-fbbe-4f55-960b-116ba9377803.png#averageHue=%23838583&clientId=ub4cb5497-3b23-4&from=paste&height=267&id=A5bqw&originHeight=401&originWidth=824&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=131276&status=done&style=none&taskId=u29168d29-32bd-489c-8371-5a8541d267a&title=&width=549.3333333333334)
基于以上结论，借助模型测试，我们做以下渲染获取刨切面作用区域：

1. 渲染裁剪后模型正面，渲染物体并将模板信息加1
2. 渲染裁剪后模型背面，渲染物体并将模板信息减1
3. 渲染裁剪平面，仅当模板信息不为0的情况渲染。

代码如下，仅为说明实现思路，完整代码请参考github  
```tsx
// define clip plane
const a = 0;
const b = 0;
const c = 1;
const d = 0;
const plane = vec4.fromValues(a, b, c, d);

// render model and clip
this.pipeline
  .setMesh(this.mesh)
  .bind(this.window)
  .clear()
  .update(this.control.projectMatrix, this.control.viewMatrix, modelMatrix, this.needRenderPlane, plane)
  .render()
  .unbind();

// render back face and +1 if stencil test pass
this.gl.enable(this.gl.CULL_FACE);
this.gl.cullFace(this.gl.BACK);
this.gl.colorMask(false, false, false, false);
this.gl.depthMask(true);
this.gl.enable(this.gl.STENCIL_TEST);
this.gl.stencilFunc(this.gl.ALWAYS, 1, 0xFF);
this.gl.stencilMask(0xFF); // allow write value, keep value that inputs
this.gl.stencilOp(this.gl.INCR_WRAP, this.gl.INCR_WRAP, this.gl.INCR_WRAP);
this.pipeline
  .setMesh(this.mesh)
  .clear()
  .update(this.control.projectMatrix, this.control.viewMatrix, modelMatrix, this.needRenderPlane, plane)
  .render()

// render front face and -1 if stencil test pass
this.gl.cullFace(this.gl.FRONT);
this.gl.colorMask(false, false, false, false);
this.gl.depthMask(false);
this.gl.stencilOp(this.gl.DECR_WRAP, this.gl.DECR_WRAP, this.gl.DECR_WRAP);
this.pipeline
  .render()
  .unbind();

// render cliped pattern when stencil not equal to 0
this.gl.disable(this.gl.CULL_FACE);
this.gl.colorMask(true, true, true, true);
this.gl.depthMask(true);
this.gl.stencilFunc(this.gl.NOTEQUAL, 0, 0xFF);
this.gl.stencilOp(this.gl.ZERO, this.gl.ZERO, this.gl.ZERO);
this.planePipeline
  .bind(this.window)
  .update(this.control.projectMatrix, this.control.viewMatrix, vec3.fromValues(1, 0, 0))
  .render()
  .unbind()

this.gl.disable(this.gl.STENCIL_TEST);
```
经过处理我们能得到刨切面的作用区域，之后只需要根据需求渲染图案即可。  
#### 与OpenGL的差异  
在刨切方面，OpenGL 3.3之后的版本支持gl_ClipDistance，我们可以在顶点着色器进行裁剪，示例代码如下：  
```cpp
glViewport(0, 0, m_window.GetWidth(), m_window.GetHeight());
glClearColor(0.f, 0.f, 0.f, 1.f);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
glEnable(GL_DEPTH_TEST);
glEnable(GL_BLEND);

glm::mat4 modelMatrix{
glm::rotate(glm::mat4(1.f), glm::pi<float>() + static_cast<float>(time), glm::vec3(0., 1., 0.))};
glm::vec4 clipPlane{0.f, 0.f, 1.f, 0.f};

glEnable(GL_CLIP_PLANE0); // enable clip plane

m_shader.Bind();
m_mesh.Bind();

m_shader.UpdateModelMatrix(modelMatrix)
    .UpdateViewMatrix(m_control.GetViewMatrix())
    .UpdateProjectionMatrix(m_control.GetProjectionMatrix())
    .UpdateClipPlane(clipPlane);

m_mesh.Render().UnBind();
m_shader.UnBind();

glDisable(GL_CLIP_PLANE0);
glDisable(GL_DEPTH_TEST);
glDisable(GL_BLEND);
```
在顶点着色器进行裁剪  
```glsl
#version 300 es

layout(location=0)in vec3 a_position;

uniform mat4 u_projectionMatrix;
uniform mat4 u_viewMatrix;
uniform mat4 u_modelMatrix;
uniform vec4 u_plane;

out vec3 v_pos;

void main(){
    gl_ClipDistance[0] = dot(u_plane, u_modelMatrix*vec4(a_position,1.f)); // clip plane
    v_pos=(u_modelMatrix*vec4(a_position,1.)).xyz;
    gl_Position=u_projectionMatrix*u_viewMatrix*u_modelMatrix*vec4(a_position,1.f);
}

```
## 图案与边框线的绘制
绘制图案以及区域边框的绘制，理想状态下是一次绘制所有内容，然而由于能力有限，边框线的绘制需要基于像素信息，使得图案的像素信息会影响边框线的绘制结果，因此需要拆分成两部分绘制——图案和边框线。  
基于之前的处理，我们已经获得需要绘制的作用区域，因此以下内容主要为shader的处理。  
### 图案的绘制
首先对于间断性的图案，需要借助某些线性变化的参数来控制绘制颜色，在这里我们借助uv来生成绘制参数ratio，将uv乘上比例系数后取小数，设置分割数值来生成绘制区域比例。  
思路如下：  
```glsl
const float patternRatio = 60.;
vec2 uv=v_uv*patternRatio;
float ratio=fract(uv.y) > 0.5 ? 1. : 0.;
```
为了绘制带有倾斜角度的图案，我们可以在shader中乘上矩阵  
```glsl
#version 300 es

precision mediump float;

const float PI=3.14;
const float patternRatio = 60.;

uniform vec3 u_color;

in vec2 v_uv;

out vec4 f_color;

mat2 rotate(float angle)
{
    angle*=PI/180.;
    float s=sin(angle),c=cos(angle);
    return mat2(c,-s,s,c);
}

void main(){
    vec2 uv=v_uv*rotate(-45.)*patternRatio;
    // use smoothstep for antialiasing
   float ratio=fract(uv.y) > 0.5 ? 1. : 0.;
    f_color=vec4(vec3(ratio)*u_color,1.);
}

```
基于此方法生成的图案，边界线比较锋利，可以基于smoothstep改变在边界线附近uv数值变化速率，从而达到一定的抗锯齿效果。  
以下为片段着色器完整代码  
```glsl
#version 300 es

precision mediump float;

const float PI=3.14;
const float patternRatio = 60.;

uniform vec3 u_color;

in vec2 v_uv;

out vec4 f_color;

mat2 rotate(float angle)
{
    angle*=PI/180.;
    float s=sin(angle),c=cos(angle);
    return mat2(c,-s,s,c);
}

void main(){
    vec2 uv=v_uv*rotate(-45.)*patternRatio;
    // use smoothstep for antialiasing
    float ratio=smoothstep(.45,.55,fract(uv.y));
    ratio+=1.-smoothstep(.45,.55,fract(uv.y+.45));
    f_color=vec4(vec3(ratio)*u_color,1.);
}

```
图案绘制结果如下  
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1688207219560-ae372fb5-c25a-45ad-9651-0b8c5d61fcb8.png#averageHue=%23191911&clientId=u02f3f154-a18e-4&from=paste&height=754&id=uf32a66dc&originHeight=1131&originWidth=1156&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=437068&status=done&style=none&taskId=u2d6b329d-dc2b-4500-8f7e-99271ab279b&title=&width=770.6666666666666)
### 边框线的绘制
边框线的绘制是本质上是一种后处理结果，基于先前处理得到的刨切面作用区域像素，提取边框信息。  
常见的边框检测为基于sobel算子和laplacian算子实现，背后是基于卷积的算法处理。由于涉及内容较多，后续再补充。  
以下为基于sobel算子的实现例子：  
```glsl
#version 300 es

precision mediump float;

uniform sampler2D u_texture;
uniform vec2 u_size;
uniform float u_hCoef[9];
uniform float u_vCoef[9];

out vec4 fColor;

void main(){
    vec2 uv=gl_FragCoord.xy/u_size;
    
    vec2 offset[9];
    offset[0]=vec2(-1.,-1.);
    offset[1]=vec2(0.,-1.);
    offset[2]=vec2(1.,-1.);
    offset[3]=vec2(-1.,0.);
    offset[4]=vec2(0.,0.);
    offset[5]=vec2(1.,0.);
    offset[6]=vec2(-1.,1.);
    offset[7]=vec2(0.,1.);
    offset[8]=vec2(1.,1.);
    
    vec3 horizonColor=vec3(0.);
    vec3 verticalColor=vec3(0.);
    
    horizonColor+=texture(u_texture,(uv+offset[0]/u_size)).rgb*u_hCoef[0];
    horizonColor+=texture(u_texture,(uv+offset[1]/u_size)).rgb*u_hCoef[1];
    horizonColor+=texture(u_texture,(uv+offset[2]/u_size)).rgb*u_hCoef[2];
    horizonColor+=texture(u_texture,(uv+offset[3]/u_size)).rgb*u_hCoef[3];
    horizonColor+=texture(u_texture,(uv+offset[4]/u_size)).rgb*u_hCoef[4];
    horizonColor+=texture(u_texture,(uv+offset[5]/u_size)).rgb*u_hCoef[5];
    horizonColor+=texture(u_texture,(uv+offset[6]/u_size)).rgb*u_hCoef[6];
    horizonColor+=texture(u_texture,(uv+offset[7]/u_size)).rgb*u_hCoef[7];
    horizonColor+=texture(u_texture,(uv+offset[8]/u_size)).rgb*u_hCoef[8];
    
    verticalColor+=texture(u_texture,(uv+offset[0]/u_size)).rgb*u_vCoef[0];
    verticalColor+=texture(u_texture,(uv+offset[1]/u_size)).rgb*u_vCoef[1];
    verticalColor+=texture(u_texture,(uv+offset[2]/u_size)).rgb*u_vCoef[2];
    verticalColor+=texture(u_texture,(uv+offset[3]/u_size)).rgb*u_vCoef[3];
    verticalColor+=texture(u_texture,(uv+offset[4]/u_size)).rgb*u_vCoef[4];
    verticalColor+=texture(u_texture,(uv+offset[5]/u_size)).rgb*u_vCoef[5];
    verticalColor+=texture(u_texture,(uv+offset[6]/u_size)).rgb*u_vCoef[6];
    verticalColor+=texture(u_texture,(uv+offset[7]/u_size)).rgb*u_vCoef[7];
    verticalColor+=texture(u_texture,(uv+offset[8]/u_size)).rgb*u_vCoef[8];
    
    vec4 color=vec4(vec3(sqrt(horizonColor*horizonColor+verticalColor*verticalColor)),1.);
    fColor=color;
}

```
边框线绘制结果如下  
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1688207267209-5f12e7a6-16b2-4e08-b4d0-4fce28860c0e.png#averageHue=%23d3ab61&clientId=u02f3f154-a18e-4&from=paste&height=845&id=u229600db&originHeight=1268&originWidth=1385&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=463652&status=done&style=none&taskId=u2986cc68-56ae-4e77-8e21-71c7ad6f694&title=&width=923.3333333333334)
结合上述两个绘制结果  
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1688205839242-7b9c9cea-dd2d-41b5-8bff-387a062ab7ec.png#averageHue=%23281f15&clientId=u02f3f154-a18e-4&from=paste&height=838&id=Dt5d5&originHeight=1257&originWidth=1407&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=574593&status=done&style=none&taskId=u961bfa2b-384f-4863-a6c6-b81f484f096&title=&width=938)
## 参考：
【1】[https://ogldev.org/www/tutorial40/tutorial40.html](https://ogldev.org/www/tutorial40/tutorial40.html)  
【2】[https://github.com/gkjohnson/three-mesh-bvh](https://github.com/gkjohnson/three-mesh-bvh)  
【3】[http://www.it.hiof.no/~borres/j3d/math/plan/p-plan.html](http://www.it.hiof.no/~borres/j3d/math/plan/p-plan.html)  
【4】[http://kjwy.5any.com/gdsx22/content/ch01/gdsx070502.htm](http://kjwy.5any.com/gdsx22/content/ch01/gdsx070502.htm)  
【5】[https://prideout.net/clip-planes](https://prideout.net/clip-planes)  
