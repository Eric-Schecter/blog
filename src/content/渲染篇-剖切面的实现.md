## 最终效果图：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1686819652220-fd846fc8-27ee-4e30-b886-3f369954e937.png#averageHue=%230a0807&clientId=ua345d7d0-e847-4&from=paste&height=977&id=uf213fff3&originHeight=1465&originWidth=2560&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=536180&status=done&style=none&taskId=ude254908-d85b-40f2-9692-17370b3f7a7&title=&width=1706.6666666666667)
## 背景说明
业务场景中需要实现刨切面渲染效果，本文基于WebGL实现并尝试解释实现思路。  
Demo：[https://webgl-renderer.netlify.app/#/clip-plane](https://webgl-renderer.netlify.app/#/clip-plane)  
Github：  
WebGL：[https://github.com/Eric-Schecter/webgl-renderer](https://github.com/Eric-Schecter/webgl-renderer)  
OpenGL：[https://github.com/Eric-Schecter/opengl-renderer](https://github.com/Eric-Schecter/opengl-renderer)  
### 原始模型
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1686837920587-7ed099db-2eae-4de8-94b3-6a7d6c41e91c.png#averageHue=%23cdf799&clientId=ub4cb5497-3b23-4&from=paste&height=925&id=u564fe52f&originHeight=1388&originWidth=1342&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=462634&status=done&style=none&taskId=u10b116a7-c6f6-4e1b-97bd-74d066b4ce5&title=&width=894.6666666666666)
## 原理解析
### 基于刨切面的裁剪
实现思路：在世界空间中构造一个虚拟平面，将模型分割成两部分。通过判断像素是否处于刨切面的一侧来选择保留或者舍弃。
###### 平面的构造：
已知平面的一般方程为：Ax+By+Cz+D=0
其中vec3(A,B,C)三个系数构成的向量为该平面的法向量，D为该平面到原点的距离。
基于以上结论，我们可以在世界空间中构造任意一个平面。
###### 模型与刨切面的位置判断：
我们设模型的世界位置信息为P(x0,y0,z0)，刨切面法线为N(A,B,C)。
将位置信息P与平面法线N做点积得到Ax0+By0+Cz0，代入上述的平面一般方程得到：
Ax0+By0+Cz0+D=0，等价于N · P + D =0
以为D代表平面到原点的距离，我们得到

- 如果 N · P + D > 0，表示点与平面法线同侧。
- 如果 N · P + D < 0，表示点与平面法线反侧。
- 如果 N · P + D = 0，表示点在平面上。

代码实现如下：
```glsl
#version 300 es

layout(location=0)in vec3 a_position;

uniform mat4 u_projectMatrix;
uniform mat4 u_viewMatrix;
uniform mat4 u_modelMatrix;

out vec3 v_pos;

void main(){
    v_pos=(u_modelMatrix*vec4(a_position,1.)).xyz; // get position in the world space
    gl_Position=u_projectMatrix*u_viewMatrix*u_modelMatrix*vec4(a_position,1.f);
}

```
```glsl
#version 300 es

precision mediump float;

uniform vec4 u_plane; // vec4(A,B,C,D)
uniform int u_needrenderplane;

in vec3 v_pos;

out vec4 f_color;

void main(){
    // judge whether mesh is in the clipping side
    if(u_needrenderplane==1&&dot(v_pos,u_plane.xyz)>u_plane.w){
        discard;
    }
    vec3 color=(v_pos+vec3(1.f))/2.f;
    f_color=vec4(color,1.);
}

```
裁剪效果如下
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1686838021230-fb72094a-bfb2-4de5-af5d-1d1f0d3de11b.png#averageHue=%230b0806&clientId=ub4cb5497-3b23-4&from=paste&height=800&id=ube59b353&originHeight=1200&originWidth=1171&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=216086&status=done&style=none&taskId=u135bcf15-e811-4212-9020-b43df955b3a&title=&width=780.6666666666666)
### 刨切面的绘制
任何封闭的物体都有正反两面的像素信息，如下图所示，左立方体为正面，右立方体为背面。
当物体被刨切时，会缺少正面的像素信息，正是我们需要着色的区域。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/34898159/1686839848903-5d168a46-fbbe-4f55-960b-116ba9377803.png#averageHue=%23838583&clientId=ub4cb5497-3b23-4&from=paste&height=267&id=A5bqw&originHeight=401&originWidth=824&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=131276&status=done&style=none&taskId=u29168d29-32bd-489c-8371-5a8541d267a&title=&width=549.3333333333334)
基于以上结论，借助模型测试，我们做以下渲染获取刨切面作用区域：

1. 渲染裁剪后模型正面，渲染物体并将模板信息加1
2. 渲染裁剪后模型背面，渲染物体并将模板信息减1
3. 渲染裁剪平面，仅当模板信息不为0的情况渲染。

代码如下，仅为说明实现思路
```tsx
// define clip plane
const a = 0;
const b = 0;
const c = 1;
const d = 0;
const plane = vec4.fromValues(a, b, c, d);

// render model and clip
this.pipeline
  .setMesh(this.mesh)
  .bind(this.window)
  .clear()
  .update(this.control.projectMatrix, this.control.viewMatrix, modelMatrix, this.needRenderPlane, plane)
  .render()
  .unbind();

// render back face and +1 if stencil test pass
this.gl.enable(this.gl.CULL_FACE);
this.gl.cullFace(this.gl.BACK);
this.gl.colorMask(false, false, false, false);
this.gl.depthMask(true);
this.gl.enable(this.gl.STENCIL_TEST);
this.gl.stencilFunc(this.gl.ALWAYS, 1, 0xFF);
this.gl.stencilMask(0xFF); // allow write value, keep value that inputs
this.gl.stencilOp(this.gl.INCR_WRAP, this.gl.INCR_WRAP, this.gl.INCR_WRAP);
this.pipeline
  .setMesh(this.mesh)
  .clear()
  .update(this.control.projectMatrix, this.control.viewMatrix, modelMatrix, this.needRenderPlane, plane)
  .render()

// render front face and -1 if stencil test pass
this.gl.cullFace(this.gl.FRONT);
this.gl.colorMask(false, false, false, false);
this.gl.depthMask(false);
this.gl.stencilOp(this.gl.DECR_WRAP, this.gl.DECR_WRAP, this.gl.DECR_WRAP);
this.pipeline
  .render()
  .unbind();

// render cliped pattern when stencil not equal to 0
this.gl.disable(this.gl.CULL_FACE);
this.gl.colorMask(true, true, true, true);
this.gl.depthMask(true);
this.gl.stencilFunc(this.gl.NOTEQUAL, 0, 0xFF);
this.gl.stencilOp(this.gl.ZERO, this.gl.ZERO, this.gl.ZERO);
this.planePipeline
  .bind(this.window)
  .update(this.control.projectMatrix, this.control.viewMatrix, vec3.fromValues(1, 0, 0))
  .render()
  .unbind()

this.gl.disable(this.gl.STENCIL_TEST);
```
之后只需要根据需求渲染图案即可。
### 与OpenGL的差异
在刨切方面，OpenGL 3.3之后的版本支持gl_ClipDistance，我们可以在顶点着色器进行裁剪，示例代码如下：
```cpp
glViewport(0, 0, m_window.GetWidth(), m_window.GetHeight());
glClearColor(0.f, 0.f, 0.f, 1.f);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
glEnable(GL_DEPTH_TEST);
glEnable(GL_BLEND);

glm::mat4 modelMatrix{
glm::rotate(glm::mat4(1.f), glm::pi<float>() + static_cast<float>(time), glm::vec3(0., 1., 0.))};
glm::vec4 clipPlane{0.f, 0.f, 1.f, 0.f};

glEnable(GL_CLIP_PLANE0); // enable clip plane

m_shader.Bind();
m_mesh.Bind();

m_shader.UpdateModelMatrix(modelMatrix)
    .UpdateViewMatrix(m_control.GetViewMatrix())
    .UpdateProjectionMatrix(m_control.GetProjectionMatrix())
    .UpdateClipPlane(clipPlane);

m_mesh.Render().UnBind();
m_shader.UnBind();

glDisable(GL_CLIP_PLANE0);
glDisable(GL_DEPTH_TEST);
glDisable(GL_BLEND);
```
在顶点着色器进行裁剪
```glsl
#version 300 es

layout(location=0)in vec3 a_position;

uniform mat4 u_projectionMatrix;
uniform mat4 u_viewMatrix;
uniform mat4 u_modelMatrix;
uniform vec4 u_plane;

out vec3 v_pos;

void main(){
    gl_ClipDistance[0] = dot(u_plane, u_modelMatrix*vec4(a_position,1.f)); // clip plane
    v_pos=(u_modelMatrix*vec4(a_position,1.)).xyz;
    gl_Position=u_projectionMatrix*u_viewMatrix*u_modelMatrix*vec4(a_position,1.f);
}

```
## TODO：添加边框线
## 参考：
【1】[https://ogldev.org/www/tutorial40/tutorial40.html](https://ogldev.org/www/tutorial40/tutorial40.html)  
【2】[https://github.com/gkjohnson/three-mesh-bvh](https://github.com/gkjohnson/three-mesh-bvh)  
【3】[http://www.it.hiof.no/~borres/j3d/math/plan/p-plan.html](http://www.it.hiof.no/~borres/j3d/math/plan/p-plan.html)  
【4】[http://kjwy.5any.com/gdsx22/content/ch01/gdsx070502.htm](http://kjwy.5any.com/gdsx22/content/ch01/gdsx070502.htm)  
【5】[https://prideout.net/clip-planes](https://prideout.net/clip-planes)  
